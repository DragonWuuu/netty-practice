# NIO

NIO（New I/O，或Non-blocking I/O），用于替代或补充传统的标准I/O。它的核心目标是提供高速、面向块（Block-oriented）、非阻塞的I/O操作、尤其适合实现高性能的网络服务器和文件操作。

## 核心概念

Channel（通道）、Buffer（缓冲区）、Slector（选择器）。

1. Channel（通道）

   类似于传统的“流”（Stream），但有几个关键区别：

   - 双线性：可以同时用于读和写。
   - 非阻塞性：可以工作在非阻塞模式下。
   - 与Buffer交互：数据总是从Channel中读取到Buffer，从Buffer中写入Channel。通道通常不存储数据。

2. Buffer（缓冲区）

   - 一个容器，本质上是一个内存块（通常是字节数组）。所有数据的读写都必须经过Buffer进行。
   - 它提供一系列的方法，可以更高效地访问和操作这些内存块。最常用的是`ByteBuffer`，除此之外还有：`CharBuffer`，`ShortBuffer`, `IntBuffer`, `LongBuffer`, `FloatBuffer`, `DoubleBuffer` 等。

3. Selector（选择器）

   - NIO的非阻塞网络编程的核心
   - 一个Selector可以同时监控多个Channel的“事件”（如：连接就绪、读就绪、写就绪）。
   - 通过一个线程管理多个Channel，从而用极少的线程处理大量连接，大大提升了服务器的可伸展性和效率。

## 工作流程

数据从不直接与Channel交换，而是通过Buffer这个“中间人”。

- 读数据：`Channel` -> `Buffer` -> `Your Program`

- 写数据：`Your Program` -> `Buffer` -> `Channel`

## flip()方法

这是理解 `Buffer` 工作机制的关键。`flip()` 方法的存在，根源在于 **Buffer 内部的状态管理机制**。

#### Buffer 的内部状态：三个关键属性

每个 Buffer 都有三个核心属性来控制数据的访问：

1. **position（位置）**：下一个要被读取或写入的元素的索引。
   - 初始为 0。
   - **写模式**：每写入一个数据，position 向后移动一位。
   - **读模式**：每读取一个数据，position 向后移动一位。
2. **limit（限制）**：第一个**不应该**被读取或写入的元素的索引。
   - 在写模式下，limit 通常等于 capacity（容量），表示可以一直写到缓冲区满。
   - 在读模式下，limit 表示缓冲区中**实际有多少有效数据**可供读取。
3. **capacity（容量）**：缓冲区所能容纳的最大数据元素数量。一旦设定，无法改变。

#### 为什么需要 flip()？—— 模式的切换

`Buffer` 的工作可以清晰地分为两种模式：**写模式** 和 **读模式**。`flip()` 方法就是用于在这两种模式之间进行切换的关键操作。

**场景模拟：**

假设我们有一个 `ByteBuffer`，容量为 8。

1. **初始状态（准备写入）**：

   - `position = 0`
   - `limit = capacity = 8`
   - `capacity = 8`
   - `[ , , , , , , , ]`

2. **写入 3 个字节数据后**：

   - `position = 3` （指向下一个要写入的位置）
   - `limit = 8`
   - `capacity = 8`
   - `[A, B, C, , , , , ]`

   现在，我们想读取刚才写入的 `A, B, C`。如果直接开始读，position 会从 3 开始，这显然是错的。我们需要将 Buffer 从**写模式切换到读模式**。

3. **调用 `buffer.flip()`**：

   - `flip()` 方法做了两件至关重要的事：
     - **将 limit 设置为当前 position 的值**（也就是 3）。这意味着最多只能读到索引 2 的位置。
     - **将 position 重置为 0**。这意味着从缓冲区的开头开始读。
   - 此时状态：
     - `position = 0`
     - `limit = 3`
     - `capacity = 8`
     - `[A, B, C, , , , , ]` (有效数据范围是 0-2)

4. **开始读取数据**：

   - 读取 2 个字节后：
     - `position = 2` （指向下一个要读取的位置 ‘C’）
     - `limit = 3`
   - 再读取 1 个字节后：
     - `position = 3` （已经到达 limit，表示没有更多数据可读了）
     - `limit = 3`

5. **读完还想再写？—— `clear()` 或 `compact()`**

   - 读完数据后，如果想重新写入，必须再次切换回写模式。这时常用两个方法：
     - `clear()`：**清空**整个缓冲区。将 `position` 设回 0，`limit` 设为 `capacity`。缓冲区看起来空了，但原有数据并未被清除，只是被“遗忘”了，下次写入会覆盖它们。
     - `compact()`：**压缩**缓冲区。将所有未读的数据（从 `position` 到 `limit`）复制到缓冲区的起始处。然后将 `position` 设置到未读数据之后的位置，`limit` 设为 `capacity`。这样既保留了未读数据，又为后续写入腾出了空间。

#### 总结：为什么需要 flip()

因为 NIO 的 `Buffer` 通过 `position`, `limit`, `capacity` 三个属性来高效管理一块内存，并明确区分了**写模式**和**读模式**。

- `flip()` 的作用就是**完成从写模式到读模式的切换**。
- 它通过将 `limit` 设置为当前写入的数据量（旧的 `position`），并将 `position` 重置为 0，来确保读取操作只能访问到有效写入的数据。
- 没有 `flip()`，就无法安全、正确地在读写模式间转换，会导致读到错误位置的数据或写入覆盖有效数据。

## 不同分配方式的ByteBuffer

当我们初始化一个ByteBuffer时，通常使用`ByteBuffer.allocate(10)`，除此之外还有`ByteBuffer.allocateDirect(10)`，它们之间的区别如下：

```java
// 该类型为HeapByteBuffer，使用的是java的堆内存。
ByteBuffer hbf = ByteBuffer.allocate(10);
System.out.println(hbf.getClass());

// 该类型为DirectByteBuffer，使用的是直接内存
ByteBuffer dbf = ByteBuffer.allocate(10);
System.out.println(dbf.getClass());
```

### 使用java堆内存和直接内存的区别

#### 核心区别一览表

| 特性           | 堆内存 (Heap Memory)                                     | 直接内存 (Direct Memory)                                     |
| :------------- | :------------------------------------------------------- | :----------------------------------------------------------- |
| **管理方**     | **Java 虚拟机 (JVM)**                                    | **操作系统 (OS)**                                            |
| **分配与回收** | 由 JVM 的垃圾回收器 (GC) 自动管理                        | 通过 `Unsafe` 或 NIO 的 `ByteBuffer` 申请，**不完全依赖 GC** |
| **分配成本**   | 相对较低                                                 | 相对较高（通过本地调用申请）                                 |
| **回收成本**   | GC 时会有停顿（Stop-the-world）                          | 回收不受 GC 直接控制，但 Full GC 会触发清理                  |
| **内存位置**   | JVM 进程内的内存空间                                     | 操作系统用户空间的内存（Off-Heap）                           |
| **数据操作**   | **需要一次拷贝**（Java 堆 -> OS 内核缓冲区）才能进行 I/O | **零拷贝**，可直接被操作系统内核用于 I/O 操作                |
| **大小限制**   | 受 JVM 最大堆参数 (`-Xmx`) 限制                          | 受操作系统可用物理内存和进程限制                             |
| **线程共享**   | 是，所有线程共享                                         | 是，所有线程共享                                             |
| **适用场景**   | 存储普通的 Java 对象实例                                 | 需要频繁与原生代码或 I/O 设备交互的大块数据                  |

------

#### 详细解释

##### 1. 堆内存 (Heap Memory)

堆内存是 JVM 管理的最大一块内存区域，也是我们最熟悉的内存。我们通过 `new` 关键字创建的所有对象实例都存储在这里。

- **管理方式**： JVM 的内存管理器负责分配，垃圾回收器 (Garbage Collector, GC) 负责自动回收不再使用的对象，释放内存。这简化了开发，但 GC 过程（尤其是 Full GC）会带来不可预测的停顿，对延迟敏感的应用是挑战。
- **I/O 操作**： 当需要基于堆内存中的数据进行 Socket 发送或文件读写时，会发生以下步骤：
  1. JVM 会将**堆中的数据**（例如一个 `byte[]` 数组）**拷贝**到一个**位于直接内存的中间缓冲区**。
  2. 操作系统内核再从这个**直接内存缓冲区**将数据写入网络或磁盘。
     这个过程多了一次不必要的拷贝，在数据量大时会影响性能。

##### 2. 直接内存 (Direct Memory)

直接内存并不是 JVM 运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。它由 JVM 通过本地（Native）方法在 Java 堆外直接向操作系统申请分配。

- **管理方式**：
  - **分配**： 通常通过 `java.nio.ByteBuffer.allocateDirect(int capacity)` 来分配。
  - **回收**： 这是关键区别。直接内存的回收**不完全依赖于 GC**。
    - 直接内存对应的 Java 对象（例如 `DirectByteBuffer` 实例）本身很小，存在于堆上，它保存着所管理的直接内存的地址。
    - 当这个 `DirectByteBuffer` 对象被 GC 回收时，**它的 `finalize()` 方法（或 Cleaner 机制）会被调用**，从而触发释放其对应的那块直接内存。
    - 因此，直接内存的回收是与堆上的 `DirectByteBuffer` 对象的 GC 绑定的。如果大量使用直接内存，但 `DirectByteBuffer` 对象却迟迟不被 GC，就会导致直接内存泄漏。
    - 最“好”的实践是**显式地调用 `DirectByteBuffer` 的 `cleaner()` 方法**（虽然不推荐直接调用，但可以通过反射）或者更好的是，**在 try-with-resources 块中使用它（如果它实现了 `AutoCloseable` 接口）**，或者在使用完毕后立即将其置为 `null`，以鼓励 GC 尽快回收。
- **I/O 操作（零拷贝优势）**：
  由于直接内存分配在操作系统用户空间，它可以被**原生代码（Native Code）直接访问**。
  - 当进行 I/O 操作（如 `FileChannel.read()` 或 `SocketChannel.write()`）时，操作系统内核可以直接从直接内存中读取数据，或者将数据直接写入直接内存。
  - **避免了将数据从 JVM 堆拷贝到操作系统内核缓冲区的额外开销**，这就是所谓的“零拷贝”（Zero-Copy）技术，能显著提升性能。

### 如何选择？

- **使用堆内存的情况**：
  - 存储大量的、生命周期短的普通 Java 对象。
  - 数据量不大，或者不涉及频繁的 I/O 操作。
  - 应用对 GC 停顿不敏感。
- **使用直接内存的情况**：
  - **需要频繁进行 I/O 操作**，如网络编程（Netty）、大型文件读写、多媒体处理等。
  - **数据生命周期较长且较大**，希望避免在堆上分配导致频繁 GC 或 GC 长时间停顿。
  - 愿意付出一些手动管理内存的代价来换取极致的性能。

### 总结

| 方面     | 堆内存                    | 直接内存                                         |
| :------- | :------------------------ | :----------------------------------------------- |
| **本质** | JVM 管理的安全内存        | 操作系统管理的“原生”内存                         |
| **性能** | 分配快，但 I/O 有拷贝开销 | 分配慢，但 I/O 零拷贝，性能高                    |
| **管理** | 全自动 GC，开发者无忧     | 需谨慎，依赖 `DirectByteBuffer` 的 GC 来间接释放 |
| **使用** | 通用场景，存储对象        | 特定高性能 I/O 场景，存储数据缓冲区              |

简单来说，**堆内存是为业务逻辑和对象服务的，而直接内存是为高性能数据传输服务的**。正确使用直接内存可以成为优化应用程序性能的强大工具。