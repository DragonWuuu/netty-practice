# NIO

NIO（New I/O，或Non-blocking I/O），用于替代或补充传统的标准I/O。它的核心目标是提供高速、面向块（Block-oriented）、非阻塞的I/O操作、尤其适合实现高性能的网络服务器和文件操作。

## 核心概念

Channel（通道）、Buffer（缓冲区）、Slector（选择器）。

1. Channel（通道）

   类似于传统的“流”（Stream），但有几个关键区别：

   - 双线性：可以同时用于读和写。
   - 非阻塞性：可以工作在非阻塞模式下。
   - 与Buffer交互：数据总是从Channel中读取到Buffer，从Buffer中写入Channel。通道通常不存储数据。

2. Buffer（缓冲区）

   - 一个容器，本质上是一个内存块（通常是字节数组）。所有数据的读写都必须经过Buffer进行。
   - 它提供一系列的方法，可以更高效地访问和操作这些内存块。最常用的是`ByteBuffer`，除此之外还有：`CharBuffer`，`ShortBuffer`, `IntBuffer`, `LongBuffer`, `FloatBuffer`, `DoubleBuffer` 等。

3. Selector（选择器）

   - NIO的非阻塞网络编程的核心
   - 一个Selector可以同时监控多个Channel的“事件”（如：连接就绪、读就绪、写就绪）。
   - 通过一个线程管理多个Channel，从而用极少的线程处理大量连接，大大提升了服务器的可伸展性和效率。

## 工作流程

数据从不直接与Channel交换，而是通过Buffer这个“中间人”。

- 读数据：`Channel` -> `Buffer` -> `Your Program`

- 写数据：`Your Program` -> `Buffer` -> `Channel`

## flip()方法

这是理解 `Buffer` 工作机制的关键。`flip()` 方法的存在，根源在于 **Buffer 内部的状态管理机制**。

#### Buffer 的内部状态：三个关键属性

每个 Buffer 都有三个核心属性来控制数据的访问：

1. **position（位置）**：下一个要被读取或写入的元素的索引。
   - 初始为 0。
   - **写模式**：每写入一个数据，position 向后移动一位。
   - **读模式**：每读取一个数据，position 向后移动一位。
2. **limit（限制）**：第一个**不应该**被读取或写入的元素的索引。
   - 在写模式下，limit 通常等于 capacity（容量），表示可以一直写到缓冲区满。
   - 在读模式下，limit 表示缓冲区中**实际有多少有效数据**可供读取。
3. **capacity（容量）**：缓冲区所能容纳的最大数据元素数量。一旦设定，无法改变。

#### 为什么需要 flip()？—— 模式的切换

`Buffer` 的工作可以清晰地分为两种模式：**写模式** 和 **读模式**。`flip()` 方法就是用于在这两种模式之间进行切换的关键操作。

**场景模拟：**

假设我们有一个 `ByteBuffer`，容量为 8。

1. **初始状态（准备写入）**：

   - `position = 0`
   - `limit = capacity = 8`
   - `capacity = 8`
   - `[ , , , , , , , ]`

2. **写入 3 个字节数据后**：

   - `position = 3` （指向下一个要写入的位置）
   - `limit = 8`
   - `capacity = 8`
   - `[A, B, C, , , , , ]`

   现在，我们想读取刚才写入的 `A, B, C`。如果直接开始读，position 会从 3 开始，这显然是错的。我们需要将 Buffer 从**写模式切换到读模式**。

3. **调用 `buffer.flip()`**：

   - `flip()` 方法做了两件至关重要的事：
     - **将 limit 设置为当前 position 的值**（也就是 3）。这意味着最多只能读到索引 2 的位置。
     - **将 position 重置为 0**。这意味着从缓冲区的开头开始读。
   - 此时状态：
     - `position = 0`
     - `limit = 3`
     - `capacity = 8`
     - `[A, B, C, , , , , ]` (有效数据范围是 0-2)

4. **开始读取数据**：

   - 读取 2 个字节后：
     - `position = 2` （指向下一个要读取的位置 ‘C’）
     - `limit = 3`
   - 再读取 1 个字节后：
     - `position = 3` （已经到达 limit，表示没有更多数据可读了）
     - `limit = 3`

5. **读完还想再写？—— `clear()` 或 `compact()`**

   - 读完数据后，如果想重新写入，必须再次切换回写模式。这时常用两个方法：
     - `clear()`：**清空**整个缓冲区。将 `position` 设回 0，`limit` 设为 `capacity`。缓冲区看起来空了，但原有数据并未被清除，只是被“遗忘”了，下次写入会覆盖它们。
     - `compact()`：**压缩**缓冲区。将所有未读的数据（从 `position` 到 `limit`）复制到缓冲区的起始处。然后将 `position` 设置到未读数据之后的位置，`limit` 设为 `capacity`。这样既保留了未读数据，又为后续写入腾出了空间。

#### 总结：为什么需要 flip()

因为 NIO 的 `Buffer` 通过 `position`, `limit`, `capacity` 三个属性来高效管理一块内存，并明确区分了**写模式**和**读模式**。

- `flip()` 的作用就是**完成从写模式到读模式的切换**。
- 它通过将 `limit` 设置为当前写入的数据量（旧的 `position`），并将 `position` 重置为 0，来确保读取操作只能访问到有效写入的数据。
- 没有 `flip()`，就无法安全、正确地在读写模式间转换，会导致读到错误位置的数据或写入覆盖有效数据。